{"version":3,"file":"event-bus.mjs","sources":["../src/event-bus.mjs"],"sourcesContent":["class EventBus {\n  constructor () {\n    if (globalThis.__ficusjs__ && globalThis.__ficusjs__.eventBus) {\n      return globalThis.__ficusjs__.eventBus\n    }\n    this.subscribers = {}\n    globalThis.__ficusjs__ = globalThis.__ficusjs__ || {}\n    globalThis.__ficusjs__.eventBus = globalThis.__ficusjs__.eventBus || this\n  }\n\n  /**\n   * Return a list of subscribers for a topic. If no topic is passed, all subscribers are returned\n   * @method\n   * @param topic\n   * @returns {Map|object} A Map of subscribers for a topic or object of all subscribers for all topics\n   */\n  getSubscribers (topic) {\n    return topic ? this.subscribers[topic] : this.subscribers\n  }\n\n  /**\n   * Subscribe to a topic\n   *\n   * @method\n   * @param {string} topic\n   * @param {function} callback\n   * @param {object} options\n   * @returns {number} A count of callbacks for this topic\n   */\n  subscribe (topic, callback, options = {}) {\n    const self = this\n    const opts = { callCount: 0, fireOnce: false, ...options }\n\n    // If there's not already an topic with this name set in our collection\n    // go ahead and create a new one and set it with an empty array, so we don't\n    // have to type check it later down-the-line\n    if (!self.subscribers[topic]) {\n      self.subscribers[topic] = new Map()\n    }\n\n    // create an unsubscribe function\n    const unsubscribe = () => {\n      const newItems = new Map()\n      self.subscribers[topic].forEach((v, k) => k !== callback && newItems.set(k, v))\n      self.subscribers[topic] = newItems\n    }\n\n    // add the callback to the map\n    self.subscribers[topic].set(callback, opts)\n\n    return unsubscribe\n  }\n\n  /**\n   * Publish a message to a topic\n   *\n   * @method\n   * @param {string} topic\n   * @param {object} data\n   * @returns {Map} The subscribers notified by this topic\n   */\n  publish (topic, data) {\n    const self = this\n\n    // There's no topic to publish to, so bail out\n    if (!self.subscribers[topic]) {\n      return []\n    }\n\n    // Get each subscription and call its callback with the passed data\n    const published = new Map()\n    self.subscribers[topic].forEach((opts, callback) => {\n      if (opts.fireOnce && opts.callCount === 1) return\n      callback(data)\n      ++opts.callCount\n      published.set(callback, opts)\n    })\n    return published\n  }\n}\n\n/**\n * Function to create an EventBus instance\n * @returns {EventBus}\n */\nexport function createEventBus () {\n  return new EventBus()\n}\n\n/**\n * Function to get the running EventBus instance\n * @returns {EventBus}\n */\nexport function getEventBus () {\n  return createEventBus()\n}\n"],"names":["EventBus","constructor","globalThis","__ficusjs__","eventBus","this","subscribers","getSubscribers","topic","subscribe","callback","options","self","opts","callCount","fireOnce","Map","set","newItems","forEach","v","k","publish","data","published","createEventBus","getEventBus"],"mappings":"AAAA,MAAMA,EACJC,cACE,GAAIC,WAAWC,aAAeD,WAAWC,YAAYC,SACnD,OAAOF,WAAWC,YAAYC,SAEhCC,KAAKC,YAAc,CAAE,EACrBJ,WAAWC,YAAcD,WAAWC,aAAe,CAAE,EACrDD,WAAWC,YAAYC,SAAWF,WAAWC,YAAYC,UAAYC,IACtE,CAQDE,eAAgBC,GACd,OAAOA,EAAQH,KAAKC,YAAYE,GAASH,KAAKC,WAC/C,CAWDG,UAAWD,EAAOE,EAAUC,EAAU,CAAA,GACpC,MAAMC,EAAOP,KACPQ,EAAO,CAAEC,UAAW,EAAGC,UAAU,KAAUJ,GAK5CC,EAAKN,YAAYE,KACpBI,EAAKN,YAAYE,GAAS,IAAIQ,KAahC,OAFAJ,EAAKN,YAAYE,GAAOS,IAAIP,EAAUG,GAPlB,KAClB,MAAMK,EAAW,IAAIF,IACrBJ,EAAKN,YAAYE,GAAOW,SAAQ,CAACC,EAAGC,IAAMA,IAAMX,GAAYQ,EAASD,IAAII,EAAGD,KAC5ER,EAAKN,YAAYE,GAASU,CAAQ,CAOrC,CAUDI,QAASd,EAAOe,GAId,IAHalB,KAGHC,YAAYE,GACpB,MAAO,GAIT,MAAMgB,EAAY,IAAIR,IAOtB,OAfaX,KASRC,YAAYE,GAAOW,SAAQ,CAACN,EAAMH,KACjCG,EAAKE,UAA+B,IAAnBF,EAAKC,YAC1BJ,EAASa,KACPV,EAAKC,UACPU,EAAUP,IAAIP,EAAUG,GAAK,IAExBW,CACR,EAOI,SAASC,iBACd,OAAO,IAAIzB,CACb,CAMO,SAAS0B,cACd,OAAOD,gBACT"}